T->S
S->ABC
A->aA
A->&
B->bB
B->&
C->cC
C->&

A->abC
A->ad
A->aB
A->aC
A->a&
B->l
C->&

<A> -> a b <C>
<A> -> a d
<A> -> a <B>
<A> -> a <C>
<B> -> l
<C> -> &


A -> B A'
A' -> a B A'
A' -> ''
B -> C B'
B' -> k C B'
B' -> ''
C -> y
C -> x C
C -> n D i
D -> ''
D -> o A z


<A> -> <A> a <B>
<A> -> <B>
<B> -> <B> k <C>
<B> -> <C>
<C> -> y
<C> -> x <C>
<C> -> n <D> i
<D> -> &
<D> -> o <A> z

A->abC
A->abd
A->aB
A->aC

Z->S
S->&
S->aS
S->bA
A->cAd
A->&


S -> real <idList>
<idList> -> <id>, <idlist>
<idlist> -> <id>
<id> -> identifier1
<id> -> identifier2
<id> -> identifier3


                        for (int k = 0; k < alternative.Length; k++)
                        {
                            List<String> featureProd = GetProductionsForFirst(alternative[k].ToString(), false);
                            bool hue = false;
                            List<bool> lolKek = new List<bool>();
                            for (int p = 0; p < lolKek.Count; p++)
                            {
                                if (!lolKek[p])
                                {
                                    hue = true;
                                }
                            }

                            if (!hue)
                            {
                                for (int y = 0; y < featureProd.Count; y++)
                                {
                                    if (!featureProd[y].Contains("&"))
                                    {
                                        lolKek.Add(true);
                                    }
                                }
                            }else
                            {
                                isEmptyNew.setIs(true);
                            }
                        }